<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTYD Randomizer - Seed Result</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
<div class="header">
    <div class="header-logo">
        <a href="{{ url_for('index') }}">
            <img src="{{ url_for('static', filename='images/logo.png') }}" alt="Home" class="logo">
        </a>
    </div>
    <div class="header-pages">
        <a href="{{ url_for('generate') }}" class="pages-link">Seed Generator</a>
        <a href="{{ url_for('test') }}" class="pages-link">Test</a>
    </div>
</div>

<div class="generate-panel">
    <h1 class="info-header">Seed Generated Successfully!</h1>

    <!-- Seed Info Section -->
    <div class="preset-section">
        <h3 class="preset-header">Seed Information</h3>
        <div id="seedInfo" style="padding: 15px; background: #f0f0f0; border-radius: 5px; margin-bottom: 20px;">
            <p><strong>Seed Number:</strong> <span id="seedNumber">Loading...</span></p>
            <p><strong>Total Locations:</strong> <span id="totalLocations">Loading...</span></p>
            <p><strong>Generated:</strong> <span id="timestamp">Loading...</span></p>
        </div>
    </div>

    <!-- ROM Patching Section -->
    <div class="preset-section">
        <h3 class="preset-header">Patch Your ROM</h3>
        <div style="padding: 15px;">
            <p>Select your TTYD (US) ISO file to apply the randomization:</p>

            <input type="file" id="romFileInput" accept=".iso,.gcm" style="display: none;">
            <button class="preset-button" onclick="document.getElementById('romFileInput').click()">
                Select ROM File
            </button>
            <span id="selectedROMName" style="margin-left: 10px; font-style: italic; color: #666;"></span>

            <div style="margin-top: 15px;">
                <button class="preset-button" id="patchBtn" onclick="patchROM()" disabled>
                    Patch ROM
                </button>
            </div>

            <!-- Progress Bar -->
            <div id="progressSection" style="display: none; margin-top: 20px;">
                <div style="background: #e0e0e0; border-radius: 5px; height: 30px; position: relative;">
                    <div id="progressBar" style="background: #4CAF50; height: 100%; border-radius: 5px; width: 0%; transition: width 0.3s;"></div>
                    <span id="progressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold;">0%</span>
                </div>
                <p id="progressStatus" style="margin-top: 10px; text-align: center;"></p>
            </div>
        </div>
    </div>

    <!-- Downloads Section -->
    <div class="preset-section" id="downloadsSection" style="display: none;">
        <h3 class="preset-header">Downloads</h3>
        <div style="padding: 15px;">
            <div id="downloadLinks"></div>
        </div>
    </div>

    <!-- Spoiler Section -->
    <div class="preset-section">
        <h3 class="preset-header">Spoiler Log</h3>
        <div style="padding: 15px;">
            <button class="preset-button" onclick="downloadSpoiler()">
                Download Spoiler Log
            </button>
        </div>
    </div>
</div>

<!-- Import gciso.js as module -->
<script type="module">
    import { parseISO, addOrReplace, rebuildISO } from '{{ url_for("static", filename="js/gciso.js") }}';

    // Make functions available globally
    window.parseISO = parseISO;
    window.addOrReplace = addOrReplace;
    window.rebuildISO = rebuildISO;
</script>

<script src="{{ url_for('static', filename='js/ips.js') }}"></script>

<script>
let seedData = null;
let romFile = null;

// Load seed data from sessionStorage
document.addEventListener('DOMContentLoaded', function() {
    const storedData = sessionStorage.getItem('ttydSeedData');

    if (!storedData) {
        alert('No seed data found. Please generate a seed first.');
        window.location.href = '/generate';
        return;
    }

    seedData = JSON.parse(storedData);
    console.log('Loaded seed data:', seedData);

    // Display seed information
    displaySeedInfo();

    // Set up ROM file input handler
    document.getElementById('romFileInput').addEventListener('change', handleROMSelection);
});

function displaySeedInfo() {
    const locationCount = Object.keys(seedData.locations).length;
    const date = new Date(seedData.timestamp);

    // Extract seed number from seedData
    const seedNumber = seedData.seed || 'Unknown';

    document.getElementById('seedNumber').textContent = seedNumber;
    document.getElementById('totalLocations').textContent = locationCount;
    document.getElementById('timestamp').textContent = date.toLocaleString();
}

function handleROMSelection(event) {
    const file = event.target.files[0];
    if (file) {
        romFile = file;
        document.getElementById('selectedROMName').textContent = file.name;
        document.getElementById('patchBtn').disabled = false;
        console.log('ROM file selected:', file.name);
    }
}

async function patchROM() {
    if (!romFile || !seedData) {
        alert('Please select a ROM file first.');
        return;
    }

    const patchBtn = document.getElementById('patchBtn');
    patchBtn.disabled = true;
    patchBtn.textContent = 'Patching...';

    const progressSection = document.getElementById('progressSection');
    progressSection.style.display = 'block';

    try {
        updateProgress(0, 'Reading ROM file...');

        // Read ROM file
        const romBuffer = await readFileAsArrayBuffer(romFile);
        console.log('ROM file loaded, size:', romBuffer.byteLength);

        updateProgress(10, 'Parsing ISO structure...');

        // Parse ISO using gciso.js
        const iso = window.parseISO(romBuffer);
        console.log('ISO parsed successfully');

        updateProgress(20, 'Loading location data...');

        // Load locations.json to get offset information
        const locationsResponse = await fetch('/static/json/locations.json');
        const locationsData = await locationsResponse.json();

        // Create location name to location data mapping
        const locationMap = new Map();
        locationsData.forEach(loc => {
            if (loc.location_name) {
                locationMap.set(loc.location_name, loc);
            }
        });

        updateProgress(30, 'Preparing location patches...');

        // Group patches by REL file
        const patchesByRel = new Map();

        Object.entries(seedData.locations).forEach(([locationName, [itemCode, playerNum]]) => {
            const locationData = locationMap.get(locationName);
            if (!locationData || !locationData.offsets || locationData.offsets.length === 0) {
                console.warn(`No offset data for location: ${locationName}`);
                return;
            }

            const rel = locationData.rel || 'dol';
            if (!patchesByRel.has(rel)) {
                patchesByRel.set(rel, []);
            }

            // Add patch for each offset
            locationData.offsets.forEach(offsetHex => {
                const offset = parseInt(offsetHex, 16);
                patchesByRel.get(rel).push({
                    offset: offset,
                    itemCode: itemCode,
                    locationName: locationName
                });
            });
        });

        console.log('Patches grouped by REL:', patchesByRel);

        updateProgress(50, 'Applying patches to files...');

        // Apply patches to each REL file and DOL
        let patchedFiles = 0;
        const totalFiles = patchesByRel.size;

        for (const [relName, patches] of patchesByRel) {
            console.log(`Patching ${relName} with ${patches.length} patches`);

            // Determine file path in ISO
            let filePath;
            if (relName === 'dol') {
                filePath = 'sys/main.dol';
            } else {
                // REL files are typically in rel/ directory
                filePath = `rel/${relName}.rel`;
            }

            // Get the file from ISO tree
            const fileNode = getNodeFromTree(iso.tree.root, filePath);
            if (!fileNode) {
                console.warn(`File not found in ISO: ${filePath}`);
                continue;
            }

            // Read file data
            const fileData = new Uint8Array(romBuffer.slice(fileNode.offset, fileNode.offset + fileNode.size));

            // Apply patches to file
            const patchedData = applyPatchesToFile(fileData, patches);

            // Replace file in ISO tree using addOrReplace
            window.addOrReplace(iso.tree, filePath, patchedData);

            patchedFiles++;
            updateProgress(50 + (30 * patchedFiles / totalFiles), `Patched ${relName}...`);
        }

        updateProgress(80, 'Rebuilding ISO...');

        // Rebuild ISO with patched files
        const patchedISO = window.rebuildISO(romBuffer, iso.tree.root);
        console.log('ISO rebuilt, size:', patchedISO.byteLength);

        updateProgress(100, 'Complete!');

        // Create download for patched ROM
        const blob = new Blob([patchedISO], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);

        const downloadsSection = document.getElementById('downloadsSection');
        const downloadLinks = document.getElementById('downloadLinks');

        downloadLinks.innerHTML = `
            <a href="${url}" download="TTYD_Randomized_Seed_${seedData.seed || 'Unknown'}.iso" class="preset-button" style="display: inline-block; margin: 5px; text-decoration: none;">
                Download Patched ROM
            </a>
        `;

        downloadsSection.style.display = 'block';

        patchBtn.textContent = 'Patch Another ROM';
        patchBtn.disabled = false;

    } catch (error) {
        console.error('Patching failed:', error);
        alert(`Patching failed: ${error.message}`);
        patchBtn.textContent = 'Patch ROM';
        patchBtn.disabled = false;
        progressSection.style.display = 'none';
    }
}

/**
 * Get a node from the ISO tree by path
 */
function getNodeFromTree(root, path) {
    const parts = path.split('/').filter(Boolean);
    let current = root;

    for (const part of parts) {
        if (!current.children || !current.children.has(part)) {
            return null;
        }
        current = current.children.get(part);
    }

    return current;
}

/**
 * Apply patches to a file buffer
 */
function applyPatchesToFile(fileData, patches) {
    // Create a copy of the file data
    const patchedData = new Uint8Array(fileData);
    const view = new DataView(patchedData.buffer);

    // Sort patches by offset to apply in order
    patches.sort((a, b) => a.offset - b.offset);

    // Apply each patch
    patches.forEach(patch => {
        // Write the item code as a 32-bit big-endian integer
        if (patch.offset + 4 <= patchedData.length) {
            view.setUint32(patch.offset, patch.itemCode, false); // false = big-endian
            console.log(`Patched ${patch.locationName} at offset 0x${patch.offset.toString(16)} with item code ${patch.itemCode}`);
        } else {
            console.warn(`Offset 0x${patch.offset.toString(16)} out of bounds for ${patch.locationName}`);
        }
    });

    return patchedData;
}

function updateProgress(percent, status) {
    document.getElementById('progressBar').style.width = percent + '%';
    document.getElementById('progressText').textContent = Math.round(percent) + '%';
    document.getElementById('progressStatus').textContent = status;
}

function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
}

async function downloadSpoiler() {
    if (!seedData) {
        alert('No seed data available.');
        return;
    }

    try {
        // Load items.json to map item codes to names
        const itemsResponse = await fetch('/static/json/items.json');
        const itemsData = await itemsResponse.json();

        // Create item code to name mapping and progression info
        const itemCodeToName = new Map();
        const itemCodeToProgression = new Map();
        itemsData.forEach(item => {
            if (item.id) {
                itemCodeToName.set(item.id, item.item_name);
                itemCodeToProgression.set(item.id, item.progression);
            }
        });

        // Generate spoiler log text
        let spoilerText = '===============================================\n';
        spoilerText += '    TTYD Randomizer - Spoiler Log\n';
        spoilerText += '===============================================\n\n';

        // Basic Info
        spoilerText += `Seed: ${seedData.seed || 'Unknown'}\n`;
        spoilerText += `Generated: ${new Date(seedData.timestamp).toLocaleString()}\n\n`;

        // Settings (excluding death_link)
        if (seedData.settings) {
            spoilerText += 'SETTINGS:\n';
            spoilerText += '---------\n';
            const gameSettings = seedData.settings['Paper Mario: The Thousand-Year Door'];
            if (gameSettings) {
                Object.entries(gameSettings)
                    .filter(([key]) => key !== 'death_link') // Exclude death_link
                    .forEach(([key, value]) => {
                        spoilerText += `  ${key}: ${value}\n`;
                    });
            }
            spoilerText += '\n';
        }

        // All Locations
        spoilerText += '='.repeat(60) + '\n';
        spoilerText += 'ITEM LOCATIONS\n';
        spoilerText += '='.repeat(60) + '\n\n';

        // Sort locations alphabetically
        const sortedLocations = Object.entries(seedData.locations).sort((a, b) => a[0].localeCompare(b[0]));

        sortedLocations.forEach(([locationName, [itemCode, playerNum]]) => {
            const itemName = itemCodeToName.get(itemCode) || `Unknown Item (${itemCode})`;
            spoilerText += `${locationName}: ${itemName}\n`;
        });

        // Statistics
        spoilerText += '='.repeat(60) + '\n';
        spoilerText += 'STATISTICS\n';
        spoilerText += '='.repeat(60) + '\n';
        spoilerText += `Total Locations: ${Object.keys(seedData.locations).length}\n`;

        // Count progression items
        let progressionItemCount = 0;
        Object.values(seedData.locations).forEach(([itemCode]) => {
            if (itemCodeToProgression.get(itemCode) === 'progression') {
                progressionItemCount++;
            }
        });
        spoilerText += `Progression Items: ${progressionItemCount}\n`;

        // Create and download the file
        const blob = new Blob([spoilerText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `TTYD_Spoiler_Seed_${seedData.seed || 'Unknown'}.txt`;
        link.click();
        URL.revokeObjectURL(url);

    } catch (error) {
        console.error('Error generating spoiler:', error);
        alert('Failed to generate spoiler log: ' + error.message);
    }
}
</script>
</body>
</html>